BELLMAN FORD

def bellman(graph,source):
   dist = [float("inf")]*(len(graph)+1)
   dist[source] = 0
   parent = [None]*(len(graph)+1)
   edge = []
   for i in range(len(graph)):
      for u,v,w in graph:
         if dist[u] != float("inf") and dist[u]+w <dist[v]:
            dist[v] = dist[u]+w
            parent[v] = u
   for i in range(len(parent)):
      if parent[i] == None:
         continue
      edge.append([parent[i],i])
   return edge,dist

graph = []
n = int(input("Enter the number of nodes: "))
for i in range(n):
   no = int(input("Enter the number of nodes connected to %d: " % (i+1)))
   for j in range(no):
      node,weight = map(int,input("enter connected node and weight:\n").split())
      graph.append([i+1,node,weight])
source = int(input("enter the source node: "))
edge,dist = bellman(graph,source)
print("Graph input: ")
for i in graph:
   print (i)
print("Edges selcted: ", edge)
print("Distance: ", dist)

COUNTING INVERSIONS
import random
import time
count = 0 

def merge_sort(li): 
    if len(li) < 2: return li      
    m = len(li) // 2      
    return merge(merge_sort(li[:m]), merge_sort(li[m:]))
def merge(l, r):     
    global count     
    result = []      
    i = j = 0
    while i < len(l) and j < len(r):          
        if l[i] < r[j]:              
            result.append(l[i])             
            i += 1      
        else:              
            result.append(r[j])             
            count = count + (len(l) - i)             
            j += 1     
    result.extend(l[i:])      
    result.extend(r[j:])      
    return result
n = int(input("Enter number of elements in the list"))
unsorted = [random.randint(0,100) for i in range(0,n)]
print("Unsorted list" , unsorted) 
start = time.clock()
print ("Sorted List" , merge_sort(unsorted))
stop = time.clock()
print ("Number of inversions = " ,count , "\nTime taken", stop-start ) 


DIASTRAS
def dijkstras(s):
   d,visited = [999]*len(graph),[0]*(len(graph))
   d[s-1] = 0
   visited[s-1] = 1
   vertices = [s]
   while len(vertices) != len(graph):
      edge={}
      for u in vertices:
         for v in graph[u]:
            if visited[v-1] == 0:
               t = d[u-1]+graph[u][v]
               edge.update({t:[u,v]})
      min_d = min(edge.keys())
      node = edge[min_d][1]
      d[node-1] = min_d
      visited[node-1] = 1
      vertices.append(node)
   return d

graph = {}
n = int(input("Enter the number of nodes in graph: "))
for i in range(n):
   graph[i+1] = {}
   no = int(input("Enter the number of nodes connected to %d" % (i+1)))
   for j in range(no):
      node,weight = map(int,input("Enter connected node and weight of edge: "))
      graph[i+1].update({node:weight})
for i in graph:
   print(i,":",graph[i])
print ("Distance array: ")
print(dijkstras(1))


PRIMS
def Prims(graph):
   U,V = set([1]),set(graph.keys())
   result = []
   while len(U) != len(V):
      minw = float('inf')
      for u in U:
         for v in graph[u]:
            if v in V-U:
               if minw > graph[u][v]:
                  minw = graph[u][v]
                  mine = [u,v]
      mine.append(minw)
      result.append(mine)
      U.add(mine[1])
   return result

graph = {}
n = int(input("Enter the number of nodes: "))
for i in range(n):
   graph[i+1]={}
   no = int(input("Enter the number of nodes connected to %d" % (i+1)))
   for j in range(no):
      node,weight = map(int,input("Enter connected node and weight of edge: "))
      graph[i+1].update({node:weight})
for i in graph:
   print (i,":",graph[i])
print ("Tree: ")
print (Prims(graph))

KRUSKAL
def find(i):
   if parent[i] == -1:
      return i
   else:
      return find(parent[i])
def union(i,j):
   i_s = find(i)
   j_s = find(j)
   parent[i_s] = j_s
def Kruskals():
   result = []
   for k in range(4):
      u = graph[k][0]
      v = graph[k][1]
      u_s = find(u)
      v_s = find(v)
      if v_s != u_s:
         result.append([u,v,graph[k][2]])
         union(u,v)
   return result

graph = []
parent = [-1]*(len(graph)+1)
n = int(input("enter the number of nodes: "))
for i in range(n):
   no = int(input("Enter the number of nodes connected to %d: " % (i+1)))
   for j in range(no):
      node,weight = map(int,input("Enter the node and weight: "))
      graph.append([(i+1),node,weight])
graph.sort(key=lambda x:x[2])
for i in graph:
   print (i)
print ("Tree: ")
print (Kruskals())

KNAPSACK
n=int(input("enter the number of items"))
W=int(input("enter the knapsack capacity"))
items=[0]
for i in range(1,n+1):   
    items.append(i)
weights=[0]
value=[0] 
for i in range(1,n+1):   
    print("enter the weight for item ",i, " : ")   
    wi=int(input())   
    weights.append(wi)   
    print("enter the value for item ",i ," : ")   
    vi=int(input())   
    value.append(vi)
print(items) 
print(weights) 
print(value) 
M = [[0 for i in range(W+1)] for j in range(n+1)] 
i = 1 
while i <= n:   
    x = 1   
    while x <= W:     
        if weights[i] > x:       
            M[i][x] = M[i-1][x]     
        else:       
            M[i][x] = max(M[i-1][x],value[i]+M[i-1][x-weights[i]])     
        x = x + 1   
    i = i + 1 
print(M) 
print("maximum value= ",M[n][W])
i=n 
k=W 
cont=[] 
while i>0 and k>0:   
    if M[i][k]!=M[i-1][k]:     
        cont.append(i)     
        k=k-weights[i]     
        i=i-1   
    else: 
        i=i-1
print("items in knapsack are: ")
print(cont) 

WEIGHTED  INTERVAL SCHEDULING
intervals = []
n = int(input("Enter the number of intervals: "))
for i in range(n):
   u = int(input("Enter start time: "))
   v = int(input("Enter end time: "))
   w = int(input("Enter interval weight: "))
   intervals.append([u,v,w])
intervals.sort(key=lambda x:x[1])
p = [0]*(len(intervals)+1)
M = [-1]*(len(intervals)+1)
M[0] = 0
def predecessor():
   for i in range(len(intervals)-1,-1,-1):
      start_time = intervals[i][0]
      for j in range(i-1,-1,-1):
         end_time = intervals[j][1]
         if end_time <= start_time:
            p[i+1] = j+1
            break
def OPT():
   for i in range(1,len(intervals)+1):
      vi = intervals[i-1][2]
      M[i] = max(vi+M[p[i]],M[i-1])
def solution():
   final_set = []
   profit = 0
   j = len(intervals)
   while j != 0:
      if intervals[j-1][2]+M[p[j]] > M[j-1]:
         final_set.append(j)
         profit += intervals[j-1][2]
         j = p[j]
      else:
         j -= 1
   return profit,final_set
predecessor()
OPT()
profit,final_set=solution()
print (profit)
print (final_set)



